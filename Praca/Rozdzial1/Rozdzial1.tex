\chapter{Podstawy Ray Tracingu}
\label{chap:podstawy}

\section{Definicje i oznaczenia}
W dalszej części będę posługiwać się takimi oznaczeniami:

\begin{itemize}
    \item $a$ - wartość skalarna.
    \item $\bm{v}$ - wektor, w więkości przypadków $\bm{v} = (x, y, z)$.
    \item $\bm{n}$ - wektor normalny. Wektor prostopadły do danej powierzchni.
    \item $\bm{a} \cdot \bm{b}$ - iloczyn skalarny.
    \item $\bm{a} \times \bm{b}$ - iloczyn wektorowy.
    \item Promień - promień (ang. ray) jest podstawową strukturą w ray tracingu. Składa się on z punktu początkowego (ang. origin) i kierunku (ang. direction). Oba elementy zdefiniowane są jako wektory trójwymiarowe, z czego kierunek jest wektorem znormalizowanym (długość równa 1).
\end{itemize}

\section{Algorytm ray tracingu}

Algorytm ray tracingu znany jest już od 1979 roku, kiedy John Turner Whitted opublikował artykuł "An improved illumination model for shaded display" opisujący rekurencyjny ray tracing [PRZYPIS]. 

Ideą algorytmu jest naśladowanie światła. W opisie zachowania się światła i jego oddziaływania z materią korzysta się z teorii falowej i optyki geometrycznej. W rzeczywistości światło porusza się po liniach prostych, od źródła np. Słońca. Ray tracing działa odwrotnie, tzn. źródłem promieni jest "oko" kamery i od niego wychodzi światło w generowaną scenę, ponieważ jak w rzeczywistości mózg człowieka "renderuje" obraz korzystając tylko z tych promieni, które padają na siatkówkę w oku [PRZYPIS]. [TUTAJ WSTAWIĆ OBRAZEK PRZEDSTAWIAJĄCY ALGORYTM].


Symulowanie światła pozwala programistom na uzyskanie szczegółowych i poprawnych fizycznie efektów takich jak: odbicie, refrakcja itd. Wcześniej, przed erą ray tracingu w czasie rzeczywistym, programiści musieli korzystać z różnych sztuczek aby zaimplementować te efekty, dla przykładu odbicia tworzone były poprzez zrenderowanie danego obiektu drugi raz ale odwrotnie w np. kałurzy, lustrze. Korzystając z ray tracingu efekt odbicia jest dużo prostszy w implementacji. 


Minusem algorytmu jest jego złożoność obliczeniowa. Dla przykładu, bez optymalizacji BVH mając model złożony z 100000 trójkątów, w rozdzielczości 2560x1440, mając ustawione 2 próbki na piksel i 5 odbiciach, program musiałby dla każdego piksela wykonać (w tej rozdzielczości mamy 3686400 pikseli) 1000000 testów. 