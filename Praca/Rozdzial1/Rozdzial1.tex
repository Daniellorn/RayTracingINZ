\chapter{Podstawy Ray Tracingu}
\label{chap:podstawy}

\section{Definicje i oznaczenia}
W dalszej części będę posługiwać się takimi oznaczeniami:

\begin{itemize}
    \item $a$ - wartość skalarna.
    \item $\bm{C}$ - punkt w przestrzeni trójwymiarowej.
    \item $\bm{v}$ - wektor, w więkości przypadków $\bm{v} = (x, y, z)$.
    \item $\bm{n}$ - wektor normalny. Wektor prostopadły do danej powierzchni.
    \item $\bm{a} \cdot \bm{b}$ - iloczyn skalarny.
    \item $\bm{a} \times \bm{b}$ - iloczyn wektorowy.
    \item Promień - promień (ang. ray) jest podstawową strukturą w ray tracingu. Składa się on z punktu początkowego (ang. origin) i kierunku (ang. direction). Oba elementy zdefiniowane są jako wektory trójwymiarowe, z czego kierunek jest wektorem znormalizowanym (długość równa 1).
\end{itemize}

\section{Algorytm ray tracingu}

Algorytm ray tracingu znany jest już od 1979 roku, kiedy John Turner Whitted opublikował artykuł "An improved illumination model for shaded display" opisujący rekurencyjny ray tracing [PRZYPIS]. 

Ideą algorytmu jest naśladowanie światła. W opisie zachowania się światła i jego oddziaływania z materią korzysta się z teorii falowej i optyki geometrycznej. W rzeczywistości światło porusza się po liniach prostych, od źródła np. Słońca. Ray tracing działa odwrotnie, tzn. źródłem promieni jest "oko" kamery i od niego wychodzi światło w generowaną scenę, ponieważ jak w rzeczywistości mózg człowieka "renderuje" obraz korzystając tylko z tych promieni, które padają na siatkówkę w oku [PRZYPIS]. Gdy wystrzelony z kamery promień uderza w jakiś obiekt punkt przecięcia staje się punktem początkowym kolejnego promienia (rekurencyjna natura algorytmu). [TUTAJ WSTAWIĆ OBRAZEK PRZEDSTAWIAJĄCY ALGORYTM].


Należy się teraz zastanowić, w jaki sposób obiekty w naturze "dostają" swój kolor. Innymi słowy - dlaczego pomidor jest czerwony? Obserwując eksperyment przedstawiający rozszczepienie światła pryzmatem, lub tęczę, możemy zauważyć, że białe światło rozszczepia się na kilka barw (w uproszczeniu). Dzieje się tak, ponieważ barwy światła mają różne długości fal. Zakres długości fal dla światła widzialnego przez człowieka wynosi: ~380-780 nanometrów. Gdy promienie ze źródła uderzą w jakiś obiekt, (np. w pomidor) to materiał obiektu wchłonie w siebie pewną część światła o danej długości, a odbije resztę. Przykładowy pomidor odbije głównie barwę czerwoną, czyli fale o długości w zakresie ~620-780 nm, następnie mózg interpretuje daną długość fali na odpowiedni kolor. W ray tracingu procedura jest podobna, jedynym dodatkiem do światła w scenie jest jego źródło, reszta oświetlenia pochodzi od promieni odbitych od obiektów. [DODAJ PRZYPIS I OBRAZEK ZAKRESU]  

Symulowanie światła pozwala programistom na uzyskanie szczegółowych i poprawnych fizycznie efektów takich jak: odbicie, refrakcja itd. Wcześniej, przed erą ray tracingu w czasie rzeczywistym, programiści musieli korzystać z różnych sztuczek aby zaimplementować te efekty, dla przykładu odbicia tworzone były poprzez zrenderowanie danego obiektu drugi raz ale odwrotnie w np. kałurzy, lustrze. Korzystając z ray tracingu efekt odbicia jest dużo prostszy w implementacji.  


Minusem algorytmu jest jego złożoność obliczeniowa. Dla przykładu, bez optymalizacji BVH mając model złożony z 100 000 trójkątów, w rozdzielczości 2560x1440, mając ustawione 2 próbki na piksel i 5 odbiciach, program musiałby dla każdego piksela wykonać (w tej rozdzielczości mamy 3686400 pikseli) 1 000 000 testów. 


\section{Badanie przecięcia promienia ze sferą}

Test przecięcia promienia ze sferą jest jednym z najprostszych algorytmów w tej tematyce i idealnie nadaje się do przedstawienie procesu wyprowadzania takich algorytmów.

Należy zacząć od zapisania równania sfery o środku w punkcie 
$\bm{C} = (c_x, c_y, c_z)$.
\begin{equation}
    (x - c_x)^2 + (y - c_y)^2 + (z - c_z)^2 = r^2
\label{eq:sphere1}
\end{equation}

Punkt $\bm{P} = (p_x, p_y, p_z)$ jest punktem leżącym na sferze. Można zapisać wektor o długości $r$ ze środka sfery do tego punktu zapisując:
\[
(\bm{P} - \bm{C})
\]
Teraz równanie sfery można zapisać tak:
\begin{equation}
    (\bm{P} - \bm{C}) \cdot (\bm{P} - \bm{C}) = r^2
\label{eq:sphere2}
\end{equation}

Każdy punkt $\bm{P}$ spełniający to równanie leży na sferze.


Szukaną wartością w tym badaniu jest zmienna $t$, na podstawie której można obliczyć współrzędne punktu $P$.
Równanie opisujące promień o punkcie początkowym $O$ i kierunku $D$: 
\begin{equation}
    \bm{P}(t) = \bm{O} + t\bm{D}
\label{eq:ray}
\end{equation}
Wstawiając~\eqref{eq:ray} do~\eqref{eq:sphere2}:
\begin{equation}
    (\bm{O} + t\bm{D} - \bm{C}) \cdot (\bm{O} + t\bm{D} - \bm{C}) = r^2
\end{equation}
Nie ma potrzeby rozpisywania całego iloczynu skalarnego, zamiast tego można zapisać: 
\begin{equation}
    (\bm{D} \cdot \bm{D})t^2 + 2t\bm{\bm{D}} \cdot (\bm{O} - \bm{C}) + (\bm{O} - \bm{C}) \cdot (\bm{O} - \bm{C}) - r^2 = 0
\label{eq:T}
\end{equation}
Jest to równanie kwadratowe o współczynnikach: 
\[
a = \bm{D} \cdot \bm{D},
b = 2\bm{D} \cdot (\bm{O} - \bm{C}),
c = (\bm{O} - \bm{C}) \cdot (\bm{O} - \bm{C}) - r^2
\]
Wzór na paramter $t$: 
\[
t = \frac{-b \pm \sqrt{b^2 - 4ac}}{2a}
\]
Równanie~\eqref{eq:T} może mieć rozwiązania dodatnie jak i ujemne. Silnik, aby poprawnie generować obrazy dla wielu sfer w scenie, potrzebuje wartości najbliższej i dodatniej (wartość ujemna świadczy o tym, że sfera jest za kamerą). W ramach oznaczenia przypadku braku rozwiązania równania~\eqref{eq:T} z funkcji zwracana jest wartość $-1.0$.  


\section{Badanie przecięcia promienia z trójkątem}

Autorami przedstawionego poniżej algorytmu są Tomas Möller i Ben Trumbore \cite{MollerTrumbore}. W odróżnieniu od innych popularnych algorytmów szukających punkt przecięcia promienia z trójkątem, ten nie oblicza równania płaszczyzny wyznaczanej przez trójkąt, tylko opiera się na samych wierzchołkach trójkąta. Istnieją szybsze algorytmy np. algorytm Douga Baldwina i Michaela Webera \cite{BaldwinWeber}, ale wymagają one dodatkowych informacji razem z trójkątami. 


\begin{definition}
Współrzędne barycentryczne na trójkącie o wierzchołkach w punktach 
$P_0, P_1, P_2$ to trójka liczb $(w, u, v) \in \mathbb{R}$, dzięki którym możemy przedstawić każdy punkt 
na trójkącie w formie:
\[
f(u,v) = (1 - u - v)\bm{P_0} + u\bm{P_1} + v\bm{P_2}.
\]
Liczby $(w, u, v)$ spełniają następujące warunki:
\[
w + u + v = 1, \quad w \ge 0, \quad u \ge 0, \quad v \ge 0.
\]
[DODAC RYSUNEK Z REAL TIME RENDERING]
\end{definition}

Znalezienie punktu przecięcia sprowadza się do rozwiązania układu równań: 
\begin{equation}
    \bm{O} + t\bm{D} = (1 - u - v)\bm{P_0} + u\bm{P_1} + v\bm{P_2}
    \label{eq:RayTri1}
\end{equation}

Gdzie $\bm{O}= (o_x, o_y, o_z)$ to punkt początkowy promienia, a $\bm{D} = (d_x, d_y, d_z)$ to kierunek.

Po przepisanu na postać macierzową: 
\begin{equation}
\begin{bmatrix}
-\bm{D} & \bm{P_1} - \bm{P_0} & \bm{P_2} - \bm{P_0}
\end{bmatrix}
\begin{pmatrix}
t \\
u \\
v
\end{pmatrix}
=
\bm{O} - \bm{P_0}
\end{equation}

Pomocnicze oznaczenia: $\bm{e_1} = \bm{P_1} - \bm{P_0}, \bm{e_2} = \bm{P_2} - \bm{P_0}, \bm{s} = \bm{O} - \bm{P_0}$

Używając oznaczeń układ równań ma postać: 
\begin{equation}
    \begin{aligned}
        -d_xt + e_{1x}u + e_{2x}v = s_x \\
        -d_yt + e_{1y}u + e_{2y}v = s_y \\
        -d_zt + e_{1z}u + e_{2z}v = s_z 
    \end{aligned}        
\end{equation}

Wtedy macierz główna układu ma postać:
\begin{equation}
    M = 
    \begin{bmatrix}
        -d_x & e_{1x} & e_{2x} \\
        -d_y & e_{1y} & e_{2y} \\
        -d_z & e_{1z} & e_{2z}
    \end{bmatrix}
\end{equation}

Do rozwiązania układu równań można wykorzystać metodę Cramera: 
\begin{equation}
    \begin{pmatrix}
    t \\
    u \\
    v
    \end{pmatrix}
=
\frac{1}{\det(-\bm{D}, \bm{e_1}, \bm{e_2})}
\begin{pmatrix}
    \det(\bm{s}, \bm{e_1}, \bm{e_2}) \\
    \det(\bm{-D}, \bm{s}, \bm{e_2}) \\
    \det(\bm{-D}, \bm{e_1}, \bm{s})
\end{pmatrix}
\end{equation}

Z własności iloczynu mieszanego wiadomo, że: $(\bm{a} \times \bm{b}) \cdot \bm{c} = \det(\bm{a}, \bm{b}, \bm{c})$
Wtedy równanie można zapisać tak (zmieniając kolumny macierzy wyznacznik zmienia znak na przeciwny): 
\begin{equation}
    \begin{pmatrix}
    t \\
    u \\
    v
    \end{pmatrix}
=
\frac{1}{(\bm{B} \times \bm{e_2}) \cdot \bm{e_1}}
\begin{pmatrix}
    (\bm{s} \times \bm{e_1}) \cdot \bm{e_2} \\
    (\bm{D} \times \bm{e_2}) \cdot \bm{s} \\
    (\bm{s} \times \bm{e_1}) \cdot \bm{D}
\end{pmatrix}
\end{equation}

Wprowadzając kolejne oznaczenia, dla uproszczenia: $\bm{q} = \bm{D} \times \bm{e_2} \\ \bm{r} = \bm{s} \times \bm{e_1}$
Otrzymane równanie:
\begin{equation}
    \begin{pmatrix}
    t \\
    u \\
    v
    \end{pmatrix}
    =
    \frac{1}{\bm{q} \cdot \bm{e_1}}
    \begin{pmatrix}
        \bm{r} \cdot \bm{e_2} \\
        \bm{q} \cdot \bm{s} \\
        \bm{r} \cdot \bm{D}
    \end{pmatrix}
\end{equation}

W implementacji funkcja zwraca parametr $t$, dzięki niemu znany jest punkt przecięcia.