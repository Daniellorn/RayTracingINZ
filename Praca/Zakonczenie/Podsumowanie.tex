\chapter*{Podsumowanie}
\addcontentsline{toc}{chapter}{Podsumowanie}
\markboth{Podsumowanie}{Podsumowanie}
\label{chap:podsumowanie}

\section{Testy}

Po zaimplementowaniu drzewa BVH zostały wykonane testy wydajności silnika. Testy opierały się mierzeniu czasu jaki zajęło zrenderowanie jednej klatki w rozdzielczości 2200 x 1331, przy 10 odbiciach i 6 promieniach na piksel. Test zapisywał czasy renderowania sceny dla 3000 klatek, następnie na podstawie zgromadzonych danych wyznaczono średnią arytmetyczną czasu potrzebnego na wygenerowanie obrazu. Renderowano model Stanford dragon zbudowany z 19332 trójkątów. Testy odbywały się w konfiguracji release z włączoną optymalizacją /Ox favor speed w Visual studio 2022 na karcie graficznej AMD Radeon RX 9070 xt.

\begin{table}[htbp]
    \centering
    \caption{Wyniki testu wydajności dla modelu Stanford Dragon}
    \label{tab:performance}
    \begin{tabular}{|l|r|}
        \hline
        \textbf{Wariant testowy} & \textbf{Średni czas renderowania klatki [ms]} \\ \hline
        Stanford Dragon (z BVH) & 19.54 \\ \hline
        Stanford Dragon (bez BVH) & 697.32 \\ \hline
    \end{tabular}
\end{table}

Nie udało się dokładnie przetestować wydajności w wariancie bez BVH. Czas renderowania modelu w rozdzielczości 2200 x 1331, 2 odbiciom i 1 promieniu na piksel wyniósł prawie 700 ms, dalsze badanie nie miało sensu. Wynik jednoznacznie potwierdza wymóg implementowania drzew BVH dla optymalizacji, bez tych struktur ray tracing w czasie rzeczywistym byłby niemożliwy. 

\begin{figure}[H]
    \centering
    \includegraphics[width=1\textwidth]{Wydajnosc} 
    \caption{Zdjęcie testowanego modelu}
    \label{fig:dragon}
\end{figure}


Przeprowadzono również testy dla mniejszego modelu zbudowanego z 264 trójkątów.

\begin{table}[htbp]
    \centering
    \caption{Wyniki testu wydajności dla modelu Tree}
    \label{tab:performance2}
    \begin{tabular}{|l|r|}
        \hline
        \textbf{Wariant testowy} & \textbf{Średni czas renderowania klatki [ms]} \\ \hline
        Tree (z BVH) & 7.76 \\ \hline
        Tree (bez BVH) & 60.00 \\ \hline
    \end{tabular}
\end{table}

Poza testami wydajności, testowano również poprawność stworzonego potoku graficznego wykorzystując wbudowane w blibliotekę DX11 funkcje. 

\begin{lstlisting}
    UINT flags = D3D11_CREATE_DEVICE_SINGLETHREADED;

#ifdef _DEBUG
		flags |= D3D11_CREATE_DEVICE_DEBUG;
#endif

	CHECK(D3D11CreateDevice(nullptr, D3D_DRIVER_TYPE_HARDWARE, nullptr, 
		flags,
		featureLevelArray, 2, D3D11_SDK_VERSION,
		&result.device, &result.featureLevel, &result.deviceContext));
\end{lstlisting}

Flaga \texttt{D3D11\_CREATE\_DEVICE\_DEBUG} aktywuje warstwę debugowania w DX11. Tryb ten rozszerza kontrolę błędów wynikających z: przesłania nieprawidłowych danych do GPU, błędnych parametrów w funkcjach tworzących potok, wycieków pamięci itd. W przypadku wystąpienia nieprawidłowości, warstwa diagnostyczna generuje szczegółowe komunikaty w oknie wyjściowym debuggera \cite{debugDX11}.

\section{Zakończenie}

Rozwój kart graficznych sprawił, że implementacja ray tracingu/path tracingu w czasie rzeczywistym nie jest czymś niemożliwym. Przedstawiony silnik nie używa pełnych możliwości sprzętu (RTCores), jednak jego wydajność po optymalizacji pozwoliła na przedstawienie podstawowych algorytmów w temacie ray tracingu. 