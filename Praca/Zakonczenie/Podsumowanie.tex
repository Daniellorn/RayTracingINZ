\chapter*{Podsumowanie}
\addcontentsline{toc}{chapter}{Podsumowanie}
\markboth{Podsumowanie}{Podsumowanie}
\label{chap:podsumowanie}

\section{Testy Wydajności}

Po zaimplementowaniu drzewa BVH zostały wykonane testy wydajności silnika. Testy opierały się mierzeniu czasu jaki zajęło zrenderowanie jednej klatki w rozdzielczości 2200 x 1331, przy 10 odbiciach i 6 promieniach na piksel. Test pobierał dane z 3000 tysięcy klatek i liczył średnią arytmetyczną czasu renderowania. Renderowano model Stanford dragon zbudowany z 19332 trójkątów. Testy odbywały się w konfiguracji release z włączoną optymalizacją /Ox favor speed w Visual studio 2022 na karcie graficznej AMD Radeon RX 9070 xt.

\begin{table}[htbp]
    \centering
    \caption{Wyniki testu wydajności dla modelu Stanford Dragon}
    \label{tab:performance}
    \begin{tabular}{|l|r|}
        \hline
        \textbf{Wariant testowy} & \textbf{Średni czas renderowania klatki [ms]} \\ \hline
        Stanford Dragon (z BVH) & 19.54 \\ \hline
        Stanford Dragon (bez BVH) & 697.32 \\ \hline
    \end{tabular}
\end{table}

Nie udało się dokładnie przetestować wydajności w wariancie bez BVH. Czas renderowania modelu w rozdzielczości 2200 x 1331, 2 odbiciom i 1 promieniu na piksel wyniósł prawie 700 ms, dalsze badanie nie miało sensu. Wynik jednoznacznie potwierdza wymóg implementowania drzew BVH dla optymalizacji, bez tych struktur ray tracing w czasie rzeczywistym byłby niemożliwy. 

\begin{figure}[H]
    \centering
    \includegraphics[width=1\textwidth]{Wydajnosc} 
    \caption{Zdjęcie testowanego modelu}
    \label{fig:dragon}
\end{figure}


Przeprowadzono również testy dla mniejszego modelu zbudowanego z 264 trójkątów.

\begin{table}[htbp]
    \centering
    \caption{Wyniki testu wydajności dla modelu Tree}
    \label{tab:performance2}
    \begin{tabular}{|l|r|}
        \hline
        \textbf{Wariant testowy} & \textbf{Średni czas renderowania klatki [ms]} \\ \hline
        Tree (z BVH) & 7.76 \\ \hline
        Tree (bez BVH) & 60.00 \\ \hline
    \end{tabular}
\end{table}

\section{Zakończenie}

Rozwój kart graficznych sprawił, że implementacja ray tracingu/path tracingu w czasie rzeczywistym nie jest czymś niemożliwym. Przedstawiony silnik nie używa pełnych możliwości sprzętu (RTCores), jednak jego wydajność po optymalizacji pozwoliła na przedstawienie podstawowych algorytmów w temacie ray tracingu. 